[
  {
    "objectID": "Classical-Mechanics/Intro_Lagrangian/main.html",
    "href": "Classical-Mechanics/Intro_Lagrangian/main.html",
    "title": "Principle of Least action and Lagrangian mechanics",
    "section": "",
    "text": "Principle of least action or Lagrangian mechanics is a formulation of classical physics that can be thought of as a generalization to Newtonian mechanics where we don’t have to use “real” or Cartesian coordinates to describe the positions and corresponding velocities of every particle. We can in fact incorporate constraints on the interaction between various particles and potentially reduce the number of required coordinates to what’s known as degrees of freedom of a system."
  },
  {
    "objectID": "Classical-Mechanics/Intro_Lagrangian/main.html#illustrating-the-action-principle",
    "href": "Classical-Mechanics/Intro_Lagrangian/main.html#illustrating-the-action-principle",
    "title": "Principle of Least action and Lagrangian mechanics",
    "section": "Illustrating the action principle",
    "text": "Illustrating the action principle\n\nThe state of a physical system in the Lagrangian formulation is given by the time, (generalized) coordinates and (generalized) velocities along every degree of freedom1.1 There are some caveats- like the coordinates are in fact maps from abstract topological manifolds and that time can sometimes refer to both a parameter or a coordinate.\n\nFor all the fuss about generalized coordinates, we’ll start from the simplest Newtonian example of a free particle in a 1D space with a single Cartesian coordinate. Action is a scalar function of paths between two fixed points in a coordinate-time graph of a system. The physical path taken by the system evolving between these two points is the one that minimizes this action. Any other path is decreed unphysical.\nSay we have two points A and B on the coordinate-time graph of the free particle. From Newton’s second law, we know the physical path is a straight line between them.\n\nWe have a (black) physical path and some (blue) unphysical paths between A and B. Note that the black line does minimize a pretty interesting quantity: the path length \\(l\\). So whatever this action (call it \\(S\\)) is, it ought to be proportional to the path length!\n\\[\nS \\propto l\n\\]\nThis delightful observation could probably have been the historical motivation to pursue this. I can indeed vaguely recollect that an action principle was being used to explain straight line trajectories of light rays. It’s also useful to write type down the expression to evaluate the path length of a generic path \\(q(t)\\):\n\\[\nl = \\int \\sqrt{dq^2 + dt^2} = \\int_0^1 dt \\sqrt{\\left(\\frac{dq}{dt}\\right)^2 + 1}\n\\tag{1}\\]\nIt’s also important avoid, in Einstein’s words “spooky action at a distance”. The dynamics of any physical system depends only on the coordinates and its derivatives at present time and not on its history. For the action principle, this means that action of a path must be the integral of a local quantity on the path (depends only on time, coordinates and their derivatives, \\(\\dot q, \\ddot q...\\) at that time). This quantity is known as the Lagrangian, \\(L\\). So we can write:\n\\[\nS = \\int_0^1 dt L(q(t), \\dot q(t), \\ddot q(t),... t)\n\\]\nTo justify this, imagine we break down the path \\(q(t)\\) into infinitesimal pieces. Since the dynamics is local, every piece would have a minimized differential action \\(dS\\) irrespective of the other pieces. Hence, \\(dS\\) must be expressed in terms of a local quantity aka the Lagrangian at time \\(t\\):\n\\[\ndS(t) = L(q(t), \\dot q(t), \\ddot q(t),... t) dt\n\\tag{2}\\]\nHowever in order to have a unique physical path between 2 points, the Lagrangian must depend only on the coordinates and velocities and not higher order derivatives:\n\\[\nL = L(q, \\dot q, t)\n\\tag{3}\\]\nIt’s no accident that the expression for path length \\(l\\) in Equation 1 also has the form of an integral over a Lagrangian, with \\(L = \\sqrt{\\dot q^2 + 1}\\). But unfortunately, it’s so close yet not there. The true Lagrangian of a free particle is defined to be the particle’s kinetic energy, giving \\(L(q, \\dot q) = \\frac{m \\dot q^2}{2}\\). In fact, the general prescription for any Newtonian system with (potential) forces for the Lagrangian would be the difference between total kinetic and potential energies:\n\\[\nL(\\vec q, \\dot{\\vec{q}}, t) = m \\frac{\\dot{\\vec{q}}.\\dot{\\vec{q}}}{2} - V(\\vec q)\n\\tag{4}\\]\nTypical textbooks on classical mechanics would’ve led straight to deriving a set of differential equations known as the Euler-Lagrange equations that yield Newton’s equations of motions for justifying the prescription in Equation 4. It’s also possible to justify Equation 3 using a property of order 2 ODEs."
  },
  {
    "objectID": "Classical-Mechanics/Intro_Lagrangian/main.html#theoretical-and-numerical-exercises",
    "href": "Classical-Mechanics/Intro_Lagrangian/main.html#theoretical-and-numerical-exercises",
    "title": "Principle of Least action and Lagrangian mechanics",
    "section": "Theoretical and numerical exercises",
    "text": "Theoretical and numerical exercises\nWe’ll try to tackle the principle of least action by directly minimizing the action over all (not all of course) possible paths instead of solving differential equations. Where do we do it? Here are some exercises in the form of Pluto notebooks with Julia code:\n\nFree particle in 1D- theoretical approach with graphs\nParticle in 2D under gravity and probably any other problem- a generic numerical approach\n\nWhy do we do it? Perhaps not necessary for classical physics- differential equations are both analytically and computationally simpler to deal with than variations over paths. But in the path integral formulation of quantum mechanics where all paths are equally physical (some of them indeed more equal than the others, as in Orwell (2021)), such numerical methods may be useful."
  },
  {
    "objectID": "Classical-Mechanics/Vectors_kinematics/main.html",
    "href": "Classical-Mechanics/Vectors_kinematics/main.html",
    "title": "Vector algebra and kinematics",
    "section": "",
    "text": "In Newtonian mechanics, we study the motion of particles in space. The “space” or the set of all particle positions is a vector space for some choice of origin, or observer position if you’d like. Elementary introductions refer to vectors as “quantities with magnitude and direction”- which is figuratively how one would characterize positions relative to an origin. Rigorous mathematical definition alludes to any set which is closed under some notion of addition and scalar multiplication. We also have a good idea of distance/length and whether any two vectors are perpendicular, so our position vector space is equipped with a dot product.\nFor any practical calculation- be it paper or computers, we must represent vectors as components wrt some basis, preferably orthonormal. In particular, we have 3 basis vectors, or space is 3 dimensional- just everyday experience or perhaps an unsaid postulate in Newtonian mechanics1. So we have the orthonormal basis \\(\\hat i, \\hat j\\) and \\(\\hat k\\) and every other vector has components given by the dot products with these vectors. Computers don’t really imagine vectors in space, hence a vector here is nothing but a list of numbers: \\[\n\\begin{align*}\n\\hat i &= [1, 0, 0] \\\\\n\\hat j &= [0, 1, 0] \\\\\n\\hat k &= [0, 0, 1] \\\\\n\\end{align*}\n\\]1 Is this really true though? Vector space assumption itself can be problematic at some level, or the fact that position and time are decoupled, or allowing continuous position values to arbitrarily small scales, we can go on. Truth has no place in science- we can say the assumption is accurate in a large domain of applicability.\nOperations over vectors include rotations (multiplication using matrices), translation (elementwise addition with another vector) and dot product (multiplication with transpose) all of which can be performed by computers numerically. Plotting libraries can help us in visualizing these operations. Here’s a Pluto notebook exercise:\nVisualizing vector algebra and calculus- Pluto notebook\nObjects in space evolve with time, a scalar quantity. The position vector of every particle is thus a function of time."
  },
  {
    "objectID": "Classical-Mechanics/Vectors_kinematics/notes.html",
    "href": "Classical-Mechanics/Vectors_kinematics/notes.html",
    "title": "Physics with Julia",
    "section": "",
    "text": "Tips and plan\n\nNeed to write a Pluto notebook on working with and visulaizing vectors in Julia.\n3D plots that are interactive- they need to work on live html like a Pluto server- I know that Plotly backend in Plots.jl works for static html but need to try the WebGL backend in Makie (still experimental but almost feature complete).\n\nThough WGLMakie has feature parity, it seems we need to add JS code in order to access live server behavior (where we have an Observable and Observer interaction- this is pretty cool in GLMakie though and should try some time).\nBut static 3D plots can still be achieved with pure Julia like with Plotly backend in Plots or WGLMakie itself, miming the CairoMakie syntax. Just live animations can be problematic.\nThat’s the plan"
  },
  {
    "objectID": "Classical-mech.html",
    "href": "Classical-mech.html",
    "title": "Classical mechanics",
    "section": "",
    "text": "Vectors and Kinematics\nLeast action principle and Lagrangian"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Traditionally, learning and research in physics have been done using the pen and paper. With recent strides in accessibility to computers (both physical and cloud). For modern sensibilities, we use a modern tool- the Julia programming language, which has speed, simplicity, elegance, emojis 😵‍💫 and the most important of all: Greek \\(\\alpha\\)-bet! The idea is to explore algorithms that aid understanding both basic and advanced concepts, that complement the traditional learning methods. As they say, A picture is worth a thousand words, so we’ll have a lot of plots/graphs throughout.\nWe have both regular web pages and Pluto notebooks which can be run interactively either using an online host or locally on your machine. Here’s an example to fool around with. Interactive notebooks are great because a widget is worth a thousand pictures.\nWhere do we go from here? If you’re new to Julia, here’s a small page with links to other guides and resources:\nJulia language resources"
  },
  {
    "objectID": "julia-tutorials.html",
    "href": "julia-tutorials.html",
    "title": "Julia language resources",
    "section": "",
    "text": "Let me state up front that Julia itself has a pretty simple and intuitive syntax for beginners and one probably doesn’t need too many guides/tutorials to understand the code we write. For example, simple functions can be defined just the way we write down on paper:\nψ(x) = cos(x) + sin(x)\nThat being said, the best way to learn something is to do it. Install Julia (preferably Linux or MacOS) on your computer first. Add the Pluto package, import and Pluto.run(), watch it open a browser window, which let’s you open either a fresh window or pre-made notebooks with introductory tutorials of some essential packages, as well as load user saved notebooks.\nIf you’re familiar with either Matlab or Python (Numpy), here’s a cheatsheet for common Julia functionality."
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Physics with Julia",
    "section": "",
    "text": "Create a Newton’s laws tutorial with numerical functions generated from Symbolics pkg rather than hardcoding them.\nThere’s a good site that alludes to the use of symbolics in physics. Precompiling symbolics generated numerical functions maybe tricky and unnecessary for tutorials. But maybe mention this as a sidenote.\nSpend enough time to set this up. No hurry at all.\n\nI would assume people already know the math and even physics to a basic extent. Emphasis will be on computer-intensive or enabled concepts and workflow.\nAn article about the advantages of Julia:\n\nIt’s fast, has a simple syntax.\nEasy building and reproducing of environments\nMultiple dispatch with structs. More physics-like than Python’s OOP.\nSimple and great plotting packages.\nSymbolics that talks well with numerics\nEasy to build and register own packages\n\n\n\n\n\nStart with the basics of vector calculus with simple library code and graphs.\n\nDo we already have a simple library for this? The functionality in Makie with Point objects seems sufficient for plotting. Find a coding API that integrates nicely with Symbolics.\nThis would probably be minimal though. Maybe the first half of an exercise on Newtonian mechanics.\nStudy CairoMakie more carefully and figure out a way to make user-friendly 2D plots that don’t overlap. One 3D plot can be shown for the sake of visualization though."
  }
]